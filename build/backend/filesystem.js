// Generated by CoffeeScript 1.8.0
var Promise, binary, chokidar, config, fs, log, mime, mkdirp, mkdirpAsync, path, pouch, remoteConfig, touch, touchAsync, uuid;

fs = require('fs');

mkdirp = require('mkdirp');

touch = require('touch');

path = require('path');

uuid = require('node-uuid');

mime = require('mime');

chokidar = require('chokidar');

log = require('printit')({
  prefix: 'Data Proxy | filesystem'
});

config = require('./config');

pouch = require('./db');

binary = require('./binary');

Promise = require('bluebird');

mkdirpAsync = Promise.promisify(mkdirp.mkdirp);

touchAsync = Promise.promisify(touch);

remoteConfig = config.getConfig();

module.exports = {
  watchingLocked: false,
  makeDirectoryFromDoc: function(doc, callback) {
    var dirPaths;
    dirPaths = this.getPaths(path.join(remoteConfig.path, doc.path, doc.name));
    log.info("Creating directory: " + dirPaths.relative);
    return mkdirpAsync(dirPaths.absolute).then(function() {
      return fs.utimesAsync(dirPaths.absolute, new Date(doc.creationDate), new Date(doc.lastModification));
    }).then(function() {
      return callback(null);
    })["catch"](function(err) {
      log.error(err.toString());
      console.error(err);
      return callback(err);
    });
  },
  touchFileFromDoc: function(doc, callback) {
    var filePaths;
    filePaths = this.getPaths(path.join(remoteConfig.path, doc.path, doc.name));
    return mkdirpAsync(filePaths.absParent).then(function() {
      return pouch.db.getAsync(doc.binary.file.id);
    })["catch"](function(err) {
      if (err.status === 404) {
        return null;
      }
    }).then(function(binaryDoc) {
      if ((binaryDoc != null) && fs.existsSync(binaryDoc.path)) {
        return binary.moveFromDocAsync(binaryDoc, filePaths.absolute);
      } else {
        log.info("Creating file: " + filePaths.relative);
        return touchAsync(filePaths.absolute);
      }
    }).then(function() {
      return fs.utimesAsync(filePaths.absolute, new Date(doc.creationDate), new Date(doc.lastModification));
    }).then(function() {
      return callback(null);
    })["catch"](function(err) {
      log.error(err.toString());
      console.error(err);
      return callback(err);
    });
  },
  buildTree: function(filePath, callback) {
    var filePaths;
    if (filePath != null) {
      filePaths = this.getPaths(filePath);
      log.info("Updating file info: " + filePaths.relative);
    } else {
      filePaths = this.getPaths(remoteConfig.path);
      log.info("Rebuilding filesystem tree");
    }
    return pouch.addFilterAsync('folder').bind(this).then(function() {
      return pouch.db.queryAsync('folder/all');
    }).get('rows').filter(function(doc) {
      return (filePath == null) || (filePaths.name === doc.value.name && filePaths.parent === doc.value.path);
    }).each(function(doc) {
      return this.makeDirectoryFromDocAsync(doc.value);
    })["catch"](function(err) {
      if (err.status !== 404) {
        throw err;
      }
    }).then(function() {
      return pouch.addFilterAsync('file');
    }).then(function() {
      return pouch.addFilterAsync('binary');
    }).then(function() {
      return pouch.db.queryAsync('file/all');
    }).get('rows').filter(function(doc) {
      return (filePath == null) || (filePaths.name === doc.value.name && filePaths.parent === doc.value.path);
    }).each(function(doc) {
      return this.touchFileFromDocAsync(doc.value);
    })["catch"](function(err) {
      if (err.status !== 404) {
        throw err;
      }
    }).then(function() {
      return callback(null);
    })["catch"](function(err) {
      log.error(err.toString());
      console.error(err);
      return callback(err);
    });
  },
  createDirectoryContentDoc: function(dirPath, callback) {
    var dirPaths;
    dirPaths = this.getPaths(dirPath);
    log.info("Add directory and its content: " + dirPaths.relative);
    return this.createDirectoryDocAsync(dirPaths.absolute).bind(this).then(function() {
      return fs.readdirAsync(dirPaths.absolute);
    }).each(function(file) {
      var filePath;
      filePath = path.join(dirPaths.absolute, file);
      return fs.lstatAsync(filePath).bind(this).then(function(stats) {
        if (stats.isDirectory()) {
          return this.createDirectoryContentDocAsync(filePath);
        } else if (stats.isFile()) {
          return this.createFileDocAsync(filePath);
        }
      });
    }).then(function() {
      return callback(null);
    })["catch"](function(err) {
      log.error(err.toString());
      console.error(err);
      return callback(err);
    });
  },
  createDirectoryDoc: function(dirPath, callback) {
    var dirPaths, document;
    dirPaths = this.getPaths(dirPath);
    if (!(this.isInSyncDir(dirPath) && fs.existsSync(dirPaths.absolute))) {
      if (!(dirPath === '' || dirPath === remoteConfig.path)) {
        log.error("Directory is not located in the synchronized directory: " + dirPaths.absolute);
      }
      return callback(null);
    }
    document = {
      _id: uuid.v4().split('-').join(''),
      docType: 'Folder',
      name: dirPaths.name,
      path: dirPaths.parent,
      tags: []
    };
    return this.createDirectoryDocAsync(dirPaths.absParent).then(function() {
      log.info("Add directory: " + dirPaths.relative);
      return fs.statAsync(dirPaths.absolute);
    }).then(function(stats) {
      document.creationDate = stats.mtime;
      document.lastModification = stats.mtime;
      return pouch.db.queryAsync('folder/all');
    }).get('rows').filter(function(doc) {
      return doc.value.name === document.name && doc.value.path === document.path;
    }).each(function(doc) {
      document._id = doc.value._id;
      document._rev = doc.value._rev;
      document.creationDate = doc.value.creationDate;
      document.tags = doc.value.tags;
      if (new Date(doc.value.lastModification) > new Date(document.lastModification)) {
        return document.lastModification = doc.value.lastModification;
      }
    })["catch"](function(err) {
      if (err.status !== 404) {
        throw err;
      }
    }).then(function() {
      return pouch.db.putAsync(document);
    }).then(function() {
      return callback(null);
    })["catch"](function(err) {
      log.error(err.toString());
      console.error(err);
      return callback(err);
    });
  },
  createFileDoc: function(filePath, callback) {
    var document, filePaths;
    filePaths = this.getPaths(filePath);
    if (!(this.isInSyncDir(filePath) && fs.existsSync(filePaths.absolute))) {
      log.error("File is not located in the synchronized directory: " + filePaths.absolute);
      return callback(null);
    }
    document = {
      _id: uuid.v4().split('-').join(''),
      docType: 'File',
      "class": 'document',
      name: filePaths.name,
      path: filePaths.parent,
      mime: mime.lookup(filePaths.name),
      tags: []
    };
    return this.createDirectoryDocAsync(filePaths.absParent).then(function() {
      log.info("Add file: " + filePaths.relative);
      return fs.statAsync(filePaths.absolute);
    }).then(function(stats) {
      document.creationDate = stats.mtime;
      document.lastModification = stats.mtime;
      document.size = stats.size;
      return pouch.db.queryAsync('file/all');
    }).get('rows').filter(function(doc) {
      return doc.value.name === document.name && doc.value.path === document.path;
    }).then(function(docs) {
      if (docs.length === 0) {
        throw {
          status: 404
        };
      }
      return docs[0].value;
    }).then(function(doc) {
      document._id = doc._id;
      document._rev = doc._rev;
      document.creationDate = doc.creationDate;
      document.tags = doc.tags;
      document.binary = doc.binary;
      if (new Date(doc.lastModification) > new Date(document.lastModification)) {
        document.lastModification = doc.lastModification;
      }
      return binary.getRemoteDocAsync(doc.binary.file.id);
    })["catch"](function(err) {
      if (err.status !== 404) {
        throw err;
      }
      return binary.createEmptyRemoteDocAsync();
    }).then(function(doc) {
      return binary.uploadAsAttachmentAsync(doc.id, doc.rev, filePaths.absolute);
    }).then(function(doc) {
      document.binary = {
        file: {
          id: doc.id,
          rev: doc.rev
        }
      };
      return binary.saveLocationAsync(filePaths.absolute, doc.id, doc.rev);
    }).then(function() {
      return pouch.db.putAsync(document);
    }).then(function() {
      return callback(null);
    })["catch"](function(err) {
      log.error(err.toString());
      console.error(err);
      return callback(err);
    });
  },
  watchChanges: function(continuous, fromNow) {
    var watcher;
    if (fromNow == null) {
      fromNow = false;
    }
    if (continuous == null) {
      continuous = fromNow;
    }
    return watcher = chokidar.watch(remoteConfig.path, {
      ignored: /[\/\\]\./,
      persistent: continuous,
      ignoreInitial: fromNow
    }).on('add', (function(_this) {
      return function(filePath) {
        if (!_this.watchingLocked) {
          log.info("File added: " + filePath);
          return _this.createFileDoc(filePath, function() {});
        }
      };
    })(this)).on('addDir', (function(_this) {
      return function(dirPath) {
        if (!_this.watchingLocked) {
          if (path !== remoteConfig.path) {
            log.info("Directory added: " + dirPath);
            return _this.createDirectoryDoc(dirPath, function() {});
          }
        }
      };
    })(this)).on('change', (function(_this) {
      return function(filePath) {
        if (!_this.watchingLocked) {
          log.info("File changed: " + filePath);
          return _this.createFileDoc(filePath, function() {});
        }
      };
    })(this)).on('error', function(err) {
      log.error('An error occured when watching changes');
      return console.error(err);
    });
  },
  getPaths: function(filePath) {
    var absParent, absolute, name, parent, relative;
    absolute = path.resolve(filePath);
    relative = path.relative(remoteConfig.path, absolute);
    name = path.basename(filePath);
    parent = path.dirname(path.join(path.sep, relative));
    absParent = path.dirname(absolute);
    if (parent === '/') {
      parent = '';
    }
    return {
      absolute: absolute,
      relative: relative,
      name: name,
      parent: parent,
      absParent: absParent
    };
  },
  isInSyncDir: function(filePath) {
    var paths;
    paths = this.getPaths(filePath);
    return paths.relative !== '' && paths.relative.substring(0, 2) !== '..';
  }
};

Promise.promisifyAll(module.exports);
